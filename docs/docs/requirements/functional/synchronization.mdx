---
sidebar_position: 9.0
title: Synchronization
status: Draft
lastUpdated: 2025-11-15
---

import RequirementMetadata from "../../../src/components/RequirementMetadata";
// noinspection ES6UnusedImports
import PriorityLabel from "../../../src/components/PriorityLabel";
// noinspection ES6UnusedImports
import StatusLabel from "../../../src/components/StatusLabel";

<RequirementMetadata/>

# Synchronization

## Overview

The Synchronization bounded context provides local-first persistence with reliable background synchronization to
optional cloud storage. It enables offline-first functionality where users can work without internet connectivity and
have their changes synchronized when the connection is restored. The context handles conflict detection and resolution
using pluggable strategies.

**Bounded context code:** SYN\
**Related DMD section:** [Synchronization (Generic)](../../domain/bounded-contexts/synchronization)

## Features

### Summary

| Feature Code | Feature Name               | Priority                                | Status                        |
|--------------|----------------------------|-----------------------------------------|-------------------------------|
| FR-SYN-001   | Local persistence          | <PriorityLabel priority="Must Have"/>   | <StatusLabel status="Draft"/> |
| FR-SYN-002   | Offline operation          | <PriorityLabel priority="Must Have"/>   | <StatusLabel status="Draft"/> |
| FR-SYN-003   | Background synchronization | <PriorityLabel priority="Must Have"/>   | <StatusLabel status="Draft"/> |
| FR-SYN-004   | Conflict detection         | <PriorityLabel priority="Should Have"/> | <StatusLabel status="Draft"/> |
| FR-SYN-005   | Conflict resolution        | <PriorityLabel priority="Should Have"/> | <StatusLabel status="Draft"/> |
| FR-SYN-006   | Sync status tracking       | <PriorityLabel priority="Must Have"/>   | <StatusLabel status="Draft"/> |
| FR-SYN-007   | Retry and error handling   | <PriorityLabel priority="Must Have"/>   | <StatusLabel status="Draft"/> |

### FR-SYN-001: Local persistence

**Priority:** <PriorityLabel priority="Must Have"/>

**Description:**  
The system must persist all user data locally using browser storage mechanisms (IndexedDB, LocalStorage) to enable
offline-first functionality. Local persistence ensures data is available immediately without network dependency and
survives browser refreshes.

**Preconditions:**

- User must be authenticated
- Browser must support local storage APIs (IndexedDB)

**Postconditions:**

- Data is persisted locally in browser storage
- Data is available for offline access
- Data survives application restarts
- Sync metadata is stored alongside data

**Business rules:**

- All user data is persisted locally by default (offline-first)
- Local storage is the primary data source; server is secondary
- Each entity has associated sync metadata (version, lastSyncedAt, pendingOps)
- Local data takes precedence until synchronized
- Storage quota limits are monitored and handled
- Sensitive data is encrypted in local storage

**User roles:**

- Authenticated User

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-002 (User Productivity Enhancement), BR-003 (Technical
Excellence), BR-005 (User Value Delivery)
- Domain Aggregates: SyncState (root)
- Domain Events: All domain events (for local persistence)

**Dependencies:**

- All bounded contexts (consume their domain events)
- Browser storage APIs (IndexedDB, LocalStorage)

**Acceptance criteria:**

- All domain events are intercepted and persisted locally
- Data is stored in IndexedDB with a structured schema
- Sync metadata (version, timestamp) is stored with each entity
- Local data is available immediately without a network call
- Storage quota is monitored and warnings shown if near the limit
- Local storage persists across browser refreshes
- Encryption is applied to sensitive fields
- Local data can be queried efficiently

**Technical notes:**

- Use IndexedDB for structured data storage (primary)
- Use LocalStorage for small metadata and settings
- Implement a structured schema with versioning for IndexedDB
- Use IndexedDB indexes for efficient queries (userId, entityType, timestamp)
- Implement encryption using Web Crypto API (AES-GCM)
- Monitor storage quota using `navigator.storage.estimate()`
- Implement storage cleanup strategies (delete old synced data)
- Use Dexie.js or similar wrapper for IndexedDB abstraction

**Open questions:**

- Should there be a maximum local storage age for data (e.g., delete data older than 90 days)?
- Should users be able to manually clear local storage?

### FR-SYN-002: Offline operation

**Priority:** <PriorityLabel priority="Must Have"/>

**Description:**  
The system must support full offline operation where users can create, read, update, and delete data without internet
connectivity. Offline operations are queued locally and synchronized when the connection is restored. The UI clearly
indicates offline status.

**Preconditions:**

- User must be authenticated (session cached locally)
- Local storage must be available
- Application must be loaded (service worker cached)

**Postconditions:**

- Operations complete successfully offline
- Changes are queued for synchronization
- UI indicates offline status
- Data is available immediately in the local state

**Business rules:**

- All CRUD operations work offline
- Offline changes are queued with operation metadata (create, update, delete)
- Queued operations are ordered by timestamp
- Conflicting offline operations are merged locally (last-write-wins within session)
- Network status is detected automatically
- UI provides clear offline indicators

**User roles:**

- Authenticated User

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-002 (User Productivity Enhancement), BR-005 (User Value
Delivery)
- Domain Aggregates: SyncState (root)
- Domain Events: All domain events (queued offline)

**Dependencies:**

- FR-SYN-001 (Local persistence)
- Service Worker for offline app shell

**Acceptance criteria:**

- User can create entities while offline
- User can update entities while offline
- User can delete entities while offline
- User can query entities while offline
- Offline operations are queued with metadata
- UI shows "Offline" badge/indicator
- Operations are complete without errors or delays
- Queued operations persist across sessions

**Technical notes:**

- Use `navigator.onLine` and online/offline event listeners for network detection
- Implement operation queue in IndexedDB with FIFO ordering
- Store operation metadata: \{ type, entityId, payload, timestamp, userId }
- Use optimistic UI updates (show changes immediately)
- Implement UI indicators (badge, banner, icon) for offline status
- Ensure a service worker caches app shell for offline loading
- Handle authentication expiration during offline periods

**Open questions:**

- Should there be a maximum size for the offline operation queue?
- Should users be warned if they've been offline for extended periods?

### FR-SYN-003: Background synchronization

**Priority:** <PriorityLabel priority="Must Have"/>

**Description:**  
The system must automatically synchronize local changes to the cloud when internet connectivity is available.
Synchronization occurs in the background without blocking user interactions. Sync is triggered on network reconnection,
periodic intervals, and user-initiated refresh.

**Preconditions:**

- User must be authenticated
- Internet connection must be available
- Local changes must exist (pending operations)

**Postconditions:**

- Pending operations are sent to server
- Server responses are processed
- Local sync state is updated
- DataSynchronized event is published
- UI indicates sync completion

**Business rules:**

- Sync occurs automatically when online
- Sync is triggered by: network reconnection, periodic intervals (e.g., every 5 minutes), user-initiated refresh
- Operations are synced in order (FIFO)
- Successful operations are marked as synced
- Failed operations are retried with exponential backoff
- Sync does not block UI interactions

**User roles:**

- Authenticated User (indirect; system behavior)

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-002 (User Productivity Enhancement), BR-003 (Technical
Excellence)
- Domain Aggregates: SyncState (root)
- Domain Events: DataSynchronized, SyncFailed

**Dependencies:**

- FR-SYN-001 (Local persistence)
- FR-SYN-002 (Offline operation)
- All bounded contexts (server APIs for sync)

**Acceptance criteria:**

- Sync triggers automatically on network reconnection
- Sync runs periodically (every 5 minutes) when online
- User can manually trigger sync via "Refresh" button
- Operations are sent to server in order
- Server responses are processed and local state updated
- Successful operations are marked as synced (lastSyncedAt timestamp)
- DataSynchronized event is published on success
- Sync progress is visible in UI (progress bar, count)
- Sync does not block user interactions

**Technical notes:**

- Use Background Sync API for reliable offline-to-online sync
- Implement sync engine with operation queue processor
- Use HTTP requests to server APIs for each operation
- Process operations sequentially (FIFO) to maintain order
- Update sync metadata after each successful operation
- Implement periodic sync with `setInterval` or Web Worker
- Use service worker for background sync when the app is closed
- Show sync progress using observables/event emitters

**Open questions:**

- Should sync be throttled during rapid changes (debouncing)?
- Should there be a "sync pause" feature for users on metered connections?

### FR-SYN-004: Conflict detection

**Priority:** <PriorityLabel priority="Should Have"/>

**Description:**  
The system should detect conflicts when local changes and server changes affect the same entity. Conflicts occur when an
entity is modified both locally (while offline) and on the server (from another device) since the last sync. Detected
conflicts are logged and prepared for resolution.

**Preconditions:**

- User has made local changes to an entity
- Server has changes to the same entity from another source
- Sync is triggered

**Postconditions:**

- Conflict is detected by comparing versions
- SyncConflictDetected event is published
- Conflict is logged with details
- User is notified (if applicable)
- Conflict is queued for resolution

**Business rules:**

- Conflicts are detected by comparing entity versions
- Each entity has a version number or etag
- Local version and server version are compared during sync
- If versions differ, a conflict exists
- Conflicts are logged with: entityId, localVersion, serverVersion, timestamp
- MVP uses last-write-wins resolution (server timestamp)
- Future: User-selectable resolution strategies

**User roles:**

- System (automatic detection)

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-003 (Technical Excellence)
- Domain Aggregates: SyncState (root)
- Domain Events: SyncConflictDetected

**Dependencies:**

- FR-SYN-003 (Background synchronization)

**Acceptance criteria:**

- Conflict is detected when local and server versions differ
- Conflict details are logged (entity, versions, timestamp)
- SyncConflictDetected event is published
- User is notified via UI notification
- Conflict is prepared for resolution
- Non-conflicting changes continue to sync

**Technical notes:**

- Use version numbers (integer) or eTags (hash) for conflict detection
- Compare versions during sync before applying server changes
- Store version metadata in SyncState aggregate
- Implement conflict log storage (database table or file)
- Use event-driven architecture to publish conflict events
- Conflicts can be resolved automatically (MVP) or require user input (future)

**Open questions:**

- Should all conflicts be logged persistently or only unresolved ones?
- Should there be a conflict history/audit trail?

### FR-SYN-005: Conflict resolution

**Priority:** <PriorityLabel priority="Should Have"/>

**Description:**  
The system should resolve detected conflicts using a defined strategy. MVP uses last-write-wins (server timestamp) as
the default resolution strategy. Future enhancements may support user-driven resolution or field-level merging.

**Preconditions:**

- Conflict must be detected (SyncConflictDetected event)
- Local and server data must be available
- Resolution strategy must be defined

**Postconditions:**

- Conflict is resolved using strategy
- Resolved entity is persisted locally
- Sync state is updated
- User is notified of the resolution (if applicable)

**Business rules:**

- MVP: Last-write-wins strategy (compare timestamps)
- Entity with the latest timestamp is kept
- Losing entity is discarded (not permanently; logged)
- Resolution is automatic (no user input in MVP)
- Future: Support for manual resolution, field-level merge, CRDT
- Resolved conflicts are logged for audit

**User roles:**

- System (automatic resolution in MVP)

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-003 (Technical Excellence)
- Domain Aggregates: SyncState (root)
- Domain Events: SyncConflictDetected (consumed), ConflictResolved (published)

**Dependencies:**

- FR-SYN-004 (Conflict detection)

**Acceptance criteria:**

- Conflict is resolved using a last-write-wins strategy
- Entity with the latest timestamp is kept
- Local data is updated with a resolved version
- Sync state is updated: \{ conflictResolved: true, resolvedAt: timestamp }
- ConflictResolved event is published (optional)
- User is notified of a resolution outcome
- Losing entity is logged (not lost)

**Technical notes:**

- Implement resolution strategies as pluggable components
- MVP: Last-write-wins using entity timestamps
- Compare timestamps in ISO 8601 format
- Future: Implement additional strategies (user-choice, field-merge, CRDT)
- Log losing entities for potential recovery
- Publish ConflictResolved events for audit trail
- Consider implementing conflict resolution UI (future)

**Open questions:**

- Should users be able to view and recover discarded conflict versions?
- Should there be configurable resolution strategies per entity type?

### FR-SYN-006: Sync status tracking

**Priority:** <PriorityLabel priority="Must Have"/>

**Description:**  
The system must provide visibility into synchronization status, including pending operations, sync progress, last sync
time, and errors. Status tracking helps users understand the state of their data and trust the synchronization process.

**Preconditions:**

- User must be authenticated
- Sync process is active or has completed

**Postconditions:**

- Sync status is visible in the UI
- Status updates in real-time
- Users can query sync status

**Business rules:**

- Sync status includes: pending operations count, last sync timestamp, sync progress, error count
- Status is updated in real-time during sync
- Status persists in local storage
- Users can query sync status via UI or API
- Status includes per-entity sync state (synced, pending, error)

**User roles:**

- Authenticated User

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-002 (User Productivity Enhancement), BR-005 (User Value
Delivery)
- Domain Aggregates: SyncState (root)
- Domain Events: All sync events

**Dependencies:**

- FR-SYN-003 (Background synchronization)

**Acceptance criteria:**

- UI displays pending operations count
- UI displays last sync timestamp
- UI displays sync progress during active sync
- UI displays the error count if sync failed
- Users can view a detailed sync status
- Status updates in real-time
- Status is accessible from the main navigation
- GetSyncStatus query returns detailed status

**Technical notes:**

- Store sync status in the SyncState aggregate
- Use observables/event emitters for real-time status updates
- Display status in UI header/footer (badge, icon, text)
- Implement GetSyncStatus query to return detailed status
- Use WebSockets or polling for real-time updates
- Cache status in local storage for quick access
- Implement status page with a detailed breakdown

**Open questions:**

- Should there be a sync activity log/history?
- Should users be able to export sync logs for debugging?

### FR-SYN-007: Retry and error handling

**Priority:** <PriorityLabel priority="Must Have"/>

**Description:**  
The system must handle synchronization errors gracefully and retry failed operations with exponential backoff. Error
handling ensures resilience to transient network issues and provides users with clear feedback and recovery options.

**Preconditions:**

- Sync operation has failed
- Error type is identified (network, server, conflict, etc.)

**Postconditions:**

- Error is logged with details
- Failed operation is queued for retry
- Retry occurs with exponential backoff
- SyncFailed event is published
- User is notified of error and retry status

**Business rules:**

- Failed operations are retried automatically
- Retry uses exponential backoff: 1s, 2s, 4s, 8s, 16s, max 60s
- Maximum retry attempts: 5 (configurable)
- After max retries, the operation is marked as failed
- Error types: Network, Server (5xx), Client (4xx), Conflict, Timeout
- Users can manually retry failed operations
- Persistent failures are escalated to user

**User roles:**

- System (automatic retry)
- Authenticated User (manual retry)

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-003 (Technical Excellence), BR-005 (User Value Delivery)
- Domain Aggregates: SyncState (root)
- Domain Events: SyncFailed

**Dependencies:**

- FR-SYN-003 (Background synchronization)

**Acceptance criteria:**

- Failed operations are automatically retried
- Retry uses exponential backoff (1s, 2s, 4s, 8s, 16s, 60s max)
- Maximum 5 (five) retry attempts
- Error is logged with type, details, and timestamp
- SyncFailed event is published
- User is notified of error and retry status
- User can manually trigger retry
- Persistent failures show an actionable error message

**Technical notes:**

- Implement retry queue with exponential backoff scheduler
- Use `setTimeout` or similar for scheduling retries
- Store retry count and next retry time in the sync state
- Classify errors by type (network, server, client, conflict)
- Log all errors with structured logging (JSON)
- Use error monitoring service (e.g., Sentry) for production
- Implement circuit breaker for repeated server failures (future)
- Provide clear, actionable error messages to users

**Open questions:**

- Should retry intervals be configurable per error type?
- Should there be a "sync health" dashboard for administrators?

## Cross-feature considerations

### Interactions between features

- **Local Persistence ↔ Offline Operation:** Local persistence enables offline operation
- **Offline Operation ↔ Background Synchronization:** Offline changes are queued and synced when online
- **Background Synchronization ↔ Conflict Detection:** Sync triggers conflict detection by comparing versions
- **Conflict Detection ↔ Conflict Resolution:** Detected conflicts are resolved using defined strategies
- **Sync Status Tracking ↔ All Features:** Status tracking monitors all sync activities
- **Retry and Error Handling ↔ Background Synchronization:** Failed sync operations are retried with backoff

### Shared business rules

1. **Offline-First:** All data operations work offline; cloud is secondary
2. **Eventual Consistency:** System guarantees eventual consistency between local and server
3. **Operation Ordering:** Operations are synced in order (FIFO) to maintain causality
4. **Conflict Resolution:** Conflicts are resolved deterministically (last-write-wins in MVP)
5. **Resilience:** Transient errors are retried; persistent errors are escalated to user
6. **Transparency:** Sync status and errors are visible to users

### Data consistency requirements

- **Local Consistency:** Strong consistency within local IndexedDB transactions
- **Eventual Consistency:** Eventual consistency between local and server
- **Conflict Resolution:** Deterministic resolution ensures consistency across devices
- **Operation Atomicity:** Each sync operation is atomic (all or nothing)
- **Idempotency:** Sync operations are idempotent (can be safely retried)

## Business constraints impact

### BC-001: Budget

Synchronization must operate within zero-cost infrastructure constraints:

- **Local Storage:** Use browser IndexedDB (free, built-in)
- **Cloud Storage:** Use a free-tier database (PostgreSQL via Railway, Supabase)
- **Sync Protocol:** Use HTTP REST APIs (no paid sync service)
- **Error Monitoring:** Use free-tier logging (no paid Sentry initially)

### BC-002: Timeline

Synchronization is important but can be simplified for MVP (3–6 months):

- **Must Have features** (FR-SYN-001, 002, 003, 006, 007) required for MVP
- **Should Have features** (FR-SYN-004, 005) can use simple strategies (last-write-wins)
- Prioritize basic offline operation and auto-sync
- Defer advanced conflict resolution (user-driven, field-merge) to post-MVP

### BC-003: Resources

Single-developer constraints affect Synchronization:

- **Simplify Conflict Resolution:** Use last-write-wins only in MVP (no CRDT)
- **Leverage Libraries:** Use Dexie.js for IndexedDB, RxJS for observables
- **Automate Testing:** Mock network conditions (offline/online) in tests
- **Incremental Development:** Build local persistence first, then offline, then sync

### BC-004: Technology stack

Synchronization aligns with the chosen stack:

- **Frontend:** Angular with service workers for offline support, RxJS for reactive sync status
- **Local Storage:** IndexedDB via Dexie.js wrapper
- **Backend:** Spring Boot REST APIs for sync endpoints
- **Database:** PostgreSQL for server-side data storage
- **Encryption:** Web Crypto API for local encryption
- **Service Worker:** Workbox for offline app shell caching

## Success metrics alignment

Synchronization contributes to the following success metrics from BR-001 through BR-008:

### BR-003: Technical metrics

| Metric                | Target        | Synchronization contribution                         |
|-----------------------|---------------|------------------------------------------------------|
| **Offline Support**   | Full function | Complete offline CRUD operations with automatic sync |
| **Sync Success Rate** | > 99%         | Reliable sync with retry and error handling          |
| **Test Coverage**     | > 80%         | Comprehensive offline/online scenario testing        |

### BR-001: Portfolio quality metrics

| Metric                         | Target             | Synchronization contribution                                        |
|--------------------------------|--------------------|---------------------------------------------------------------------|
| **Architecture Documentation** | All views complete | Offline-first architecture, sync engine design, conflict resolution |
| **Code Quality Score**         | No critical issues | Clean sync logic, proper error handling, testable offline code      |

### BR-002, BR-005: User experience metrics

| Metric                   | Target         | Synchronization contribution                               |
|--------------------------|----------------|------------------------------------------------------------|
| **Offline Capability**   | Must Have      | Full app functionality offline, seamless online/offline    |
| **Sync Transparency**    | High           | Clear status indicators, error messages, progress tracking |
| **Data Loss Prevention** | Zero data loss | Reliable sync with conflict detection and resolution       |

## Traceability matrix

| Feature    | Business Req                   | Domain Events                                     | User Stories |
|------------|--------------------------------|---------------------------------------------------|--------------|
| FR-SYN-001 | BR-001, BR-002, BR-003, BR-005 | All domain events (for persistence)               | US-SYN-001-* |
| FR-SYN-002 | BR-001, BR-002, BR-005         | All domain events (queued offline)                | US-SYN-002-* |
| FR-SYN-003 | BR-001, BR-002, BR-003         | DataSynchronized, SyncFailed                      | US-SYN-003-* |
| FR-SYN-004 | BR-001, BR-003                 | SyncConflictDetected                              | US-SYN-004-* |
| FR-SYN-005 | BR-001, BR-003                 | SyncConflictDetected (consumed), ConflictResolved | US-SYN-005-* |
| FR-SYN-006 | BR-001, BR-002, BR-005         | All sync events                                   | US-SYN-006-* |
| FR-SYN-007 | BR-001, BR-003, BR-005         | SyncFailed                                        | US-SYN-007-* |