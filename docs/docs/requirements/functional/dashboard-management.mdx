---
sidebar_position: 2
title: Dashboard Management
status: Draft
lastUpdated: 2025-11-15
---


import RequirementMetadata from "../../../src/components/RequirementMetadata";
import PriorityLabel from "../../../src/components/PriorityLabel";
import StatusLabel from "../../../src/components/StatusLabel";

<RequirementMetadata status={frontMatter.status} lastUpdated={frontMatter.lastUpdated}/>

# Dashboard management

## Overview

The Dashboard Management bounded context is the core differentiator of the Browser Dashboard PWA. It orchestrates
dashboard composition, layout, and personalization—enabling users to create, customize, and manage their personalized
dashboard experience.

**Bounded context code:** DAS\
**Related DMD section:** [Dashboard Management (Core)](../../domain/bounded-contexts/dashboard-management)

---

## Features summary

| Feature Code | Feature Name               | Priority                                | Status                        |
|--------------|----------------------------|-----------------------------------------|-------------------------------|
| FR-DAS-001   | Dashboard creation         | <PriorityLabel priority="Must Have"/>   | <StatusLabel status="Draft"/> |
| FR-DAS-002   | Widget instance management | <PriorityLabel priority="Must Have"/>   | <StatusLabel status="Draft"/> |
| FR-DAS-003   | Widget configuration       | <PriorityLabel priority="Must Have"/>   | <StatusLabel status="Draft"/> |
| FR-DAS-004   | Layout management          | <PriorityLabel priority="Must Have"/>   | <StatusLabel status="Draft"/> |
| FR-DAS-005   | Widget reordering          | <PriorityLabel priority="Must Have"/>   | <StatusLabel status="Draft"/> |
| FR-DAS-006   | Personalization profiles   | <PriorityLabel priority="Should Have"/> | <StatusLabel status="Draft"/> |
| FR-DAS-007   | Dashboard deletion         | <PriorityLabel priority="Must Have"/>   | <StatusLabel status="Draft"/> |
| FR-DAS-008   | Dashboard persistence      | <PriorityLabel priority="Must Have"/>   | <StatusLabel status="Draft"/> |

---

## FR-DAS-001: Dashboard creation

**Priority:** Must Have

**Description:**  
Users must be able to create a new dashboard. Each user is initially provided with a default dashboard upon
registration, but the system shall support the creation of additional dashboards for future extensibility (even if the
MVP limits users to a single dashboard).

**Preconditions:**

- User must be authenticated
- User identity must be available from the Identity & Access context

**Postconditions:**

- A new Dashboard aggregate is created
- Dashboard is associated with the user's identity
- Dashboard has an empty widget instances collection
- Dashboard has a default layout configuration
- DashboardCreated event is published

**Business rules:**

- A dashboard must belong to exactly one user
- Dashboard must have a unique identifier (DashboardId)
- Dashboard names (if provided) must be non-empty and length-bounded
- Default layout is a single-column grid

**User roles:**

- Authenticated User

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-002 (User Productivity Enhancement), BR-005 (User Value
Delivery)
- Domain Aggregates: Dashboard (root)
- Domain Events: DashboardCreated, UserRegistered (consumed)

**Dependencies:**

- User Identity context (Conformist relationship)

**Acceptance criteria:**

- Dashboard is created with valid DashboardId
- Dashboard is persisted in the database
- Dashboard is associated with the authenticated user
- DashboardCreated event is published with userId and dashboardId
- Default empty layout is initialized
- User can view their newly created dashboard

**User stories:**

- US-DAS-001-001: Create default dashboard on registration
- US-DAS-001-002: View empty dashboard after creation

---

#### Scenarios

##### Scenario 1: Create the default dashboard on user registration (happy path)

```gherkin
Given a new user has just registered and been authenticated
When the system processes the UserRegistered event
Then a default dashboard is automatically created for the user
And the dashboard has an empty widget instances collection
And the dashboard has a default single-column layout
And a DashboardCreated event is published
```

##### Scenario 2: View a newly created dashboard

```gherkin
Given a dashboard has just been created for a user  
When the user navigates to their dashboard view  
Then they see an empty dashboard with placeholder content  
And they see instructions on how to add widgets  
And the layout is rendered correctly
```

##### Scenario 3: Dashboard creation failure — invalid User

```gherkin
Given an attempt is made to create a dashboard
When the user identity is invalid or not found  
Then the dashboard creation fails  
And an appropriate error message is returned  
And no DashboardCreated event is published
```

---

**Technical notes:**

- Dashboard creation is typically triggered by the UserRegistered event
- Consider using eventual consistency for the dashboard creation process
- Ensure transactional consistency within the Dashboard aggregate
- Dashboard IDs should be generated using a strongly-typed identifier pattern

**Open questions:**

- Should users be able to name their dashboards in the MVP, or defer to future iterations?
- Should there be a maximum number of dashboards per user?

---

## FR-DAS-002: Widget instance management

**Priority:** Must Have

**Description:**
Users must be able to add and remove widget instances from their dashboard. Widget instances represent concrete
placements of widget types (e.g., "Weather widget for Madrid", "Bookmarks widget showing Work folder").

**Preconditions:**

- User must be authenticated
- User must have an existing dashboard
- Widget type must be valid and registered in the system

**Postconditions:**

- Widget instance is added to or removed from the dashboard
- Layout is updated to accommodate the change
- WidgetAddedToDashboard or WidgetRemovedFromDashboard event is published

**Business rules:**

- A widget instance must reference a valid widget type
- Widget instances must have unique identifiers within a dashboard
- A widget type can have multiple instances on the same dashboard (e.g., multiple weather widgets for different cities)
- Layout positions cannot overlap
- Widget instance configuration must conform to the widget type's schema

**User roles:**

- Authenticated User

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-002 (User Productivity Enhancement), BR-005 (User Value
Delivery)
- Domain Aggregates: Dashboard (root), WidgetInstance
- Domain Events: WidgetAddedToDashboard, WidgetRemovedFromDashboard

**Dependencies:**

- Widget Registry (must validate widget types)
- FR-DAS-001 (Dashboard must exist)

**Acceptance criteria:**

- User can add a widget instance by selecting a widget type
- Widget instance is assigned a unique WidgetInstanceId
- Widget instance is added to the dashboard's widget instances collection
- Widget instance is positioned according to layout rules
- WidgetAddedToDashboard event is published
- User can remove a widget instance
- Widget instance is removed from the dashboard
- WidgetRemovedFromDashboard event is published
- Layout is recalculated to close gaps after removal

**User stories:**

- US-DAS-002-001: Add a widget to dashboard
- US-DAS-002-002: Remove a widget from dashboard
- US-DAS-002-003: Add multiple instances of the same widget type

---

#### Scenarios

##### Scenario 1: Add the first widget to a dashboard (happy path)

```gherkin
Given a user has an empty dashboard  
When the user selects "Add Widget" and chooses "Bookmarks"  
Then a new Bookmarks widget instance is created  
And the widget is added to the dashboard at the first available position  
And the widget has default configuration values  
And a WidgetAddedToDashboard event is published  
And the dashboard view updates to show the new widget
```

##### Scenario 2: Add a second instance of the same widget type

```gherkin
Given a user already has a Weather widget for London on their dashboard  
When the user adds another Weather widget for Madrid  
Then both widget instances coexist on the dashboard  
And each has a unique WidgetInstanceId  
And each has independent configuration (London vs Madrid)  
And layout positions do not overlap
```

##### Scenario 3: Remove a widget from a dashboard

```gherkin
Given a user has multiple widgets on their dashboard  
When the user selects "Remove" on a specific widget instance  
Then a confirmation dialog appears  
And upon confirmation, the widget instance is removed  
And a WidgetRemovedFromDashboard event is published  
And the layout is recalculated to close the gap  
And other widgets shift to fill the space
```

##### Scenario 4: Adda a widget with an invalid type

```gherkin
Given a user attempts to add a widget  
When the widget type is not registered or invalid  
Then the operation fails with a validation error  
And an error message is displayed to the user  
And no WidgetAddedToDashboard event is published
```

##### Scenario 5: Remove widget — cancel confirmation

```gherkin
Given a user initiates widget removal  
When the confirmation dialog is displayed  
And the user clicks "Cancel"  
Then the widget is not removed  
And no WidgetRemovedFromDashboard event is published  
And the dashboard remains unchanged
```

---

**Technical notes:**

- Widget types must be validated against a widget registry before creating instances
- Widget configurations should be schema-validated to ensure compatibility
- Consider implementing undo/redo functionality for widget operations
- Layout recalculation should maintain visual stability (minimize jarring rearrangements)

**Open questions:**

- Should there be a maximum number of widget instances per dashboard?
- Should removed widgets be archived instead of permanently deleted?

---

## FR-DAS-003: Widget configuration

**Priority:** Must Have

**Description:**  
Users must be able to configure individual widget instances. Each widget type has its own configuration schema (e.g.,
Weather widget needs a location, Bookmarks widget needs a folder selection). The Dashboard context is responsible for
persisting these configurations.

**Preconditions:**

- User must be authenticated
- Widget instance must exist on the dashboard
- Configuration values must conform to the widget type's schema

**Postconditions:**

- Widget instance configuration is updated
- Configuration is persisted
- WidgetConfigurationChanged event is published
- Widget is refreshed with new configuration

**Business rules:**

- Configuration must validate against the widget type's schema
- Configuration changes must be atomic (all or nothing)
- Invalid configurations are rejected
- Default configuration values are provided for new widget instances

**User roles:**

- Authenticated User

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-002 (User Productivity Enhancement),  BR-003 (Technical
Excellence), BR-005 (User Value Delivery)
- Domain Aggregates: WidgetInstance
- Domain Events: WidgetConfigurationChanged

**Dependencies:**

- FR-DAS-002 (Widget instance must exist)
- Widget type schema validation

**Acceptance criteria:**

- User can open configuration settings for a widget instance
- Configuration UI is widget-type-specific
- Configuration values are validated before saving
- Invalid configurations show appropriate error messages
- Valid configuration changes are persisted immediately
- WidgetConfigurationChanged event is published
- Widget instance updates to reflect new configuration
- Configuration changes are reflected in real-time

**User stories:**

- US-DAS-003-001: Configure weather widget location
- US-DAS-003-002: Configure bookmarks widget folder
- US-DAS-003-003: Validate invalid configuration

---

#### Scenarios

##### Scenario 1: Configure weather widget location (happy path)

```gherkin
Given a user has a Weather widget on their dashboard  
When the user opens the widget settings  
And changes the location from "London" to "Madrid"  
And clicks "Save"  
Then the configuration is validated against the Weather widget schema  
And the location is updated to "Madrid"  
And a WidgetConfigurationChanged event is published  
And the widget refreshes to show Madrid weather data
```

##### Scenario 2: Configure bookmarks widget folder selection

```gherkin
Given a user has a Bookmarks widget on their dashboard  
When the user opens the widget settings  
And selects "Work" folder from available folders  
And clicks "Save"  
Then the configuration is updated  
And the widget displays only bookmarks from the "Work" folder  
And a WidgetConfigurationChanged event is published
```

##### Scenario 3: Invalid configuration — missing required field

```gherkin
Given a user is configuring a widget  
When the user leaves a required configuration field empty  
And attempts to save  
Then validation fails  
And an error message highlights the missing field  
And the configuration is not saved  
And no WidgetConfigurationChanged event is published
```

##### Scenario 4: Invalid configuration — schema violation

```gherkin
Given a user is configuring a Weather widget  
When the user enters an invalid location (e.g., "XYZ123")  
And attempts to save  
Then schema validation fails  
And an error message indicates the location is invalid  
And the configuration is not saved  
And the widget retains its previous configuration
```

##### Scenario 5: Cancel configuration changes

```gherkin
Given a user has opened widget settings  
And made changes to the configuration  
When the user clicks "Cancel"  
Then changes are discarded  
And the widget retains its previous configuration  
And no WidgetConfigurationChanged event is published
```

---

**Technical notes:**

- Use JSON Schema or similar for widget configuration validation
- Configuration UI should be dynamically generated based on widget schema
- Consider implementing configuration versioning for backward compatibility
- Optimize for minimal data transfer (only send changed values)

**Open questions:**

- Should configuration changes be undoable?
- Should there be validation warnings in addition to errors (e.g., "This location has limited weather data")?

---

## FR-DAS-004: Layout management

**Priority:** Must Have

**Description:**  
The system must manage the layout of widget instances on the dashboard, ensuring proper positioning, sizing, and
responsive behavior. Layout defines the grid/region structure, ordering rules, and sizing constraints.

**Preconditions:**

- Dashboard must exist
- Widget instances must exist on the dashboard

**Postconditions:**

- Layout is calculated and persisted
- Widget instances are positioned according to layout rules
- Layout is responsive to different screen sizes

**Business rules:**

- Layout positions cannot overlap
- Ordering is total within a region (each widget has a defined position)
- Default layout is a single-column grid
- Layout must be responsive (adapt to screen sizes)
- Minimum widget size constraints must be enforced
- Maximum number of widgets per row may be limited

**User roles:**

- Authenticated User

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-002 (User Productivity Enhancement), BR-005 (User Value
Delivery)
- Domain Aggregates: Layout, Dashboard
- Domain Events: LayoutChanged (future)

**Dependencies:**

- FR-DAS-002 (Widget instances must exist)

**Acceptance criteria:**

- Layout is automatically calculated when widgets are added/removed
- Layout prevents overlapping positions
- Layout is responsive to screen size changes
- Widget instances maintain stable positions across sessions
- Layout is persisted with the dashboard
- Empty dashboard shows placeholder layout
- Layout adapts gracefully to different screen sizes (desktop, tablet, mobile)

**User stories:**

- US-DAS-004-001: View dashboard with automatic layout
- US-DAS-004-002: Dashboard layout adapts to mobile screen
- US-DAS-004-003: Layout prevents widget overlap

---

#### Scenarios

##### Scenario 1: Automatic layout calculation (happy path)

```gherkin
Given a user has a dashboard with three widgets  
When the dashboard is rendered  
Then the layout engine calculates positions for all widgets  
And widgets are arranged in a single-column grid  
And no widgets overlap  
And widgets fill the available width  
And vertical spacing is consistent
```

##### Scenario 2: Responsive layout - mobile view

```gherkin
Given a user has a dashboard with multiple widgets  
When the user views the dashboard on a mobile device  
Then the layout adapts to a single-column view  
And widgets stack vertically  
And widget widths fill the mobile screen  
And spacing is adjusted for mobile viewing
```

##### Scenario 3: Layout after widget removal

```gherkin
Given a user has a dashboard with four widgets in a grid layout  
When the user removes the second widget  
Then the layout is recalculated  
And the gap is closed  
And remaining widgets shift to maintain a cohesive layout  
And no empty spaces remain in the middle of the layout
```

##### Scenario 4: Layout persistence

```gherkin
Given a user has arranged widgets on their dashboard  
When the user logs out and logs back in  
Then the layout is restored exactly as it was  
And all widget positions are preserved  
And no widgets have shifted or overlapped
```

##### Scenario 5: Responsive layout — window resize

```gherkin
Given a user is viewing their dashboard on desktop  
When the user resizes the browser window  
Then the layout adapts in real-time  
And widgets reflow to fit the new width  
And no widgets are cut off or hidden  
And the transition is smooth
```

---

**Technical notes:**

- Consider using CSS Grid or Flexbox for responsive layout
- Layout algorithm should be deterministic and stable
- Implement layout caching to minimize recalculations
- Consider grid-based layout system (12-column grid or similar)
- Ensure layout works well with browser zoom levels

**Open questions:**

- Should the system support multiple layout presets (grid, masonry, custom)?
- Should minimum/maximum widget sizes be configurable per widget type?

---

## FR-DAS-005: Widget reordering

**Priority:** Must Have

**Description:**
Users must be able to reorder widget instances on their dashboard by dragging and dropping them. This allows users to
prioritize and organize their dashboard according to their preferences.

**Preconditions:**

- User must be authenticated
- Dashboard must have at least two widget instances
- User must have drag capability (desktop or touch device)

**Postconditions:**

- Widget instance positions are updated
- New order is persisted
- WidgetReordered event is published
- Visual feedback confirms the change

**Business rules:**

- Ordering must be total within a layout region
- Drag operation must provide visual feedback
- Drop zones must be clearly indicated
- Order changes must be atomic (complete or rollback)
- Layout constraints must be maintained after reordering

**User roles:**

- Authenticated User

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-002 (User Productivity Enhancement), BR-005 (User Value
Delivery)
- Domain Aggregates: Dashboard, WidgetInstance, Layout
- Domain Events: WidgetReordered

**Dependencies:**

- FR-DAS-002 (Widget instances must exist)
- FR-DAS-004 (Layout management)

**Acceptance criteria:**

- User can drag a widget by clicking and holding
- Visual feedback shows the widget being dragged
- Drop zones are highlighted during drag
- Widget is repositioned when dropped in a valid location
- Other widgets shift to accommodate the moved widget
- WidgetReordered event is published with old and new positions
- New order is persisted immediately
- Drag operation can be cancelled (ESC key or drag outside)
- Touch devices support drag-and-drop

**User stories:**

- US-DAS-005-001: Reorder widgets by drag-and-drop
- US-DAS-005-002: Cancel drag operation
- US-DAS-005-003: Reorder widgets on touch device

---

#### Scenarios

##### Scenario 1: Reorder widgets by drag-and-drop (happy path)

```gherkin
Given a user has a dashboard with four widgets (A, B, C, D) in that order  
When the user drags widget D to the position between A and B  
Then widget D is visually lifted and follows the cursor  
And drop zones between other widgets are highlighted  
And when dropped, the order becomes: A, D, B, C  
And a WidgetReordered event is published  
And the new order is persisted  
And other widgets smoothly animate to their new positions
```

##### Scenario 2: Reorder widgets — first to last position

```gherkin
Given a user has a dashboard with widgets (A, B, C) in that order  
When the user drags widget A to the end of the list  
Then the order becomes: B, C, A  
And the layout is recalculated  
And the change is persisted  
And a WidgetReordered event is published
```

##### Scenario 3: Cancel drag operation

```gherkin
Given a user starts dragging a widget  
When the user presses the ESC key before dropping  
Then the drag operation is cancelled  
And the widget returns to its original position  
And no WidgetReordered event is published  
And the order remains unchanged
```

##### Scenario 4: Drag widget outside valid drop zone

```gherkin
Given a user is dragging a widget  
When the user releases the widget outside any valid drop zone  
Then the widget snaps back to its original position  
And no reordering occurs  
And no WidgetReordered event is published
```

##### Scenario 5: Reorder widgets on touch device

```gherkin
Given a user is viewing their dashboard on a touch device  
When the user long-presses a widget and then drags it  
Then the widget enters drag mode  
And follows the touch point  
And can be dropped in a new position  
And the same reordering logic applies as desktop
```

---

**Technical notes:**

- Implement smooth animations for drag-and-drop feedback
- Use optimistic UI updates for perceived performance
- Consider implementing haptic feedback on mobile devices
- Ensure accessibility for keyboard-only users (alternative reorder mechanism)
- Throttle reorder events to avoid excessive persistence operations

**Open questions:**

- Should there be a "Reorder Mode" toggle to make reordering easier?
- Should undo functionality be available for accidental reorders?

---

## FR-DAS-006: Personalization profiles

**Priority:** Should Have

**Description:**  
Users should be able to create and switch between multiple personalization profiles (e.g., "Work", "Home", "Travel").
Each profile contains a different dashboard configuration including widgets, layout, and settings.

**Preconditions:**

- User must be authenticated
- User must have at least one dashboard (default profile)

**Postconditions:**

- New profile is created with associated dashboard
- User can switch between profiles
- Active profile is persisted
- ProfileSwitched event is published

**Business rules:**

- Each profile must have a unique name per user
- Profile names must be non-empty and length-bounded
- Default profile cannot be deleted
- Switching profiles loads the associated dashboard
- Each profile maintains independent widget configurations

**User roles:**

- Authenticated User

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-002 (User Productivity Enhancement), BR-004 (Scalability and
Maintainability), BR-005 (User Value Delivery)
- Domain Aggregates: Dashboard (each profile has its own dashboard)
- Domain Events: ProfileCreated, ProfileSwitched, ProfileDeleted

**Dependencies:**

- FR-DAS-001 (Dashboard creation)
- FR-DAS-002 (Widget management)

**Acceptance criteria:**

- User can create a new profile with a unique name
- User can switch between existing profiles
- Active profile is indicated in the UI
- Switching profiles loads the associated dashboard configuration
- ProfileSwitched event is published
- Profile names are validated for uniqueness
- User can rename profiles
- User can delete non-default profiles
- Last active profile is restored on login

**User stories:**

- US-DAS-006-001: Create a new personalization profile
- US-DAS-006-002: Switch between profiles
- US-DAS-006-003: Rename a profile
- US-DAS-006-004: Delete a profile

---

#### Scenarios

##### Scenario 1: Create a new profile (happy path)

```gherkin
Given a user is viewing their default dashboard  
When the user clicks "Create New Profile"  
And enters the name "Work"  
And confirms creation  
Then a new profile named "Work" is created  
And a new empty dashboard is associated with the profile  
And the user is switched to the new "Work" profile  
And a ProfileCreated event is published  
And the profile is added to the profile selector
```

##### Scenario 2: Switch between profiles

```gherkin
Given a user has two profiles: "Default" and "Work"  
And the "Default" profile is currently active  
When the user selects "Work" from the profile selector  
Then the current dashboard is saved  
And the "Work" dashboard is loaded  
And a ProfileSwitched event is published  
And widgets and layout from "Work" profile are displayed  
And the profile selector shows "Work" as active
```

##### Scenario 3: Create a profile with duplicate name

```gherkin
Given a user already has a profile named "Work"  
When the user attempts to create another profile named "Work"  
Then validation fails  
And an error message indicates the name is already in use  
And the profile is not created  
And no ProfileCreated event is published
```

##### Scenario 4: Delete non-default profile

```gherkin
Given a user has three profiles: "Default", "Work", and "Home"  
And "Home" profile is currently active  
When the user deletes the "Home" profile  
Then a confirmation dialog appears  
And upon confirmation, the "Home" profile is deleted  
And the user is switched to the "Default" profile  
And a ProfileDeleted event is published  
And "Home" is removed from the profile selector
```

##### Scenario 5: Attempt to delete default profile

```gherkin
Given a user is viewing their "Default" profile  
When the user attempts to delete the "Default" profile  
Then the operation is prevented  
And an error message indicates the default profile cannot be deleted  
And no ProfileDeleted event is published
```

##### Scenario 6: Restore last active profile on login

```gherkin
Given a user's last active profile was "Work"  
When the user logs out and logs back in  
Then the "Work" profile is automatically loaded  
And the dashboard associated with "Work" is displayed
```

---

**Technical notes:**

- Consider implementing profile templates for quick setup
- Each profile should have its own dashboard aggregate
- Profile switching should be optimized for performance (lazy loading)
- Consider implementing profile export/import functionality
- Profile metadata should include creation date, last modified, last accessed

**Open questions:**

- Should there be a maximum number of profiles per user?
- Should profile switching support keyboard shortcuts?
- Should profiles have their own themes/colors?

---

## FR-DAS-007: Dashboard deletion

**Priority:** Must Have

**Description:**  
The system must support dashboard deletion as part of the dashboard lifecycle. While users may not directly delete their
primary dashboard in the MVP, the capability is needed for cleanup operations and future profile management.

**Preconditions:**

- Dashboard must exist
- Dashboard must not be the user's only/default dashboard (in profile scenario)
- User must have appropriate permissions

**Postconditions:**

- Dashboard is deleted
- All associated widget instances are removed
- Layout configuration is removed
- DashboardDeleted event is published

**Business rules:**

- Default/primary dashboard cannot be deleted if it's the user's only dashboard
- Deletion is permanent (no soft delete in MVP)
- All widget instances are cascade deleted
- Deletion must be atomic (all or nothing)
- User must confirm deletion action

**User roles:**

- Authenticated User

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-002 (User Productivity Enhancement), BR-005 (User Value
Delivery)
- Domain Aggregates: Dashboard (root)
- Domain Events: DashboardDeleted

**Dependencies:**

- FR-DAS-001 (Dashboard must exist)

**Acceptance criteria:**

- Dashboard can be deleted via explicit command
- Confirmation is required before deletion
- All widget instances are removed
- Layout configuration is removed
- DashboardDeleted event is published
- User is redirected to another dashboard (if multiple exist)
- The default dashboard cannot be deleted if it's the only one
- Deletion is atomic (transaction boundary)

**User stories:**

- US-DAS-007-001: Delete a dashboard (profile scenario)
- US-DAS-007-002: Prevent deletion of only dashboard

---

#### Scenarios

##### Scenario 1: Delete dashboard (happy path — multiple profiles)

```gherkin
Given a user has two profiles with associated dashboards: "Default" and "Work"  
And the user is viewing the "Work" dashboard  
When the user selects "Delete Dashboard" from the profile menu  
Then a confirmation dialog appears warning of permanent deletion  
And upon confirmation, the "Work" dashboard is deleted  
And all widget instances on the "Work" dashboard are removed  
And a DashboardDeleted event is published  
And the user is switched to the "Default" dashboard
```

##### Scenario 2: Attempt to delete only dashboard

```gherkin
Given a user has only one dashboard (the default dashboard)  
When the user attempts to delete this dashboard  
Then the operation is prevented  
And an error message indicates the last dashboard cannot be deleted  
And no DashboardDeleted event is published
```

##### Scenario 3: Cancel dashboard deletion

```gherkin
Given a user initiates dashboard deletion  
When the confirmation dialog appears  
And the user clicks "Cancel"  
Then the deletion is aborted  
And the dashboard remains unchanged  
And no DashboardDeleted event is published
```

##### Scenario 4: Dashboard deletion on account deletion

```gherkin
Given a user requests account deletion  
When the account deletion process runs  
Then all dashboards associated with the user are deleted  
And DashboardDeleted events are published for each dashboard  
And all widget instances are cascade deleted
```

---

**Technical notes:**

- Ensure proper cascade deletion of widget instances
- Consider implementing soft delete for audit purposes (future)
- Dashboard deletion should be transactional
- Consider archiving dashboard configurations before deletion (future)
- Ensure foreign key constraints are properly handled

**Open questions:**

- Should deleted dashboards be recoverable (soft delete) instead of permanent deletion?
- Should there be a "trash" or "archive" feature for dashboards?

---

## FR-DAS-008: Dashboard persistence

**Priority:** Must Have

**Description:**
The system must persist all dashboard states, including the dashboard configuration, widget instances, widget
configurations, and layout. This ensures users can resume their personalized experience across sessions and devices.

**Preconditions:**

- Dashboard must exist
- User must be authenticated

**Postconditions:**

- Dashboard state is persisted to storage
- State can be retrieved on later access
- Consistency is maintained across concurrent updates

**Business rules:**

- All dashboard changes must be persisted immediately
- Widget configurations must validate before persistence
- Concurrent updates must be handled safely
- Persistence must be transactional (ACID properties)
- Failed persistence must not corrupt dashboard state

**User roles:**

- Authenticated User

**Related to:**

- Business Requirements: BR-001 (Portfolio Enhancement), BR-002 (User Productivity Enhancement), BR-003 (Technical
Excellence), BR-005 (User Value Delivery)
- Domain Aggregates: Dashboard (root), WidgetInstance, Layout
- Domain Events: All dashboard events

**Dependencies:**

- Storage infrastructure (database)
- All other FR-DAS features depend on persistence

**Acceptance criteria:**

- Dashboard state is persisted immediately after changes
- Widget additions/removals are persisted
- Widget configuration changes are persisted
- Widget reordering is persisted
- Layout changes are persisted
- Profile switches are persisted
- Dashboard can be retrieved exactly as last saved
- Concurrent updates are handled safely (optimistic locking)
- Failed persistence operations are logged and reported
- Persistence operations are atomic

**User stories:**

- US-DAS-008-001: Resume dashboard across sessions
- US-DAS-008-002: Handle concurrent dashboard updates

---

#### Scenarios

##### Scenario 1: Persist dashboard after widget addition (happy path)

```gherkin
Given a user has a dashboard loaded  
When the user adds a new widget  
Then the widget instance is immediately persisted to storage  
And the dashboard's widget instances collection is updated  
And the layout is recalculated and persisted  
And persistence completes successfully
```

##### Scenario 2: Resume dashboard across sessions

```gherkin
Given a user has configured their dashboard with multiple widgets  
And the user logs out  
When the user logs back in from a different device  
Then the dashboard is retrieved from storage  
And all widget instances are restored  
And all widget configurations are restored  
And the layout is restored exactly as before  
And the dashboard appears identical to when the user logged out
```

##### Scenario 3: Handle concurrent update conflict

```gherkin
Given a user has their dashboard open in two browser tabs  
When the user adds a widget in tab 1  
And simultaneously adds a different widget in tab 2  
Then optimistic locking detects the conflict  
And one operation succeeds immediately  
And the other operation is retried with the updated state  
And both widgets are successfully added  
And no data is lost
```

##### Scenario 4: Persistence failure — network error

```gherkin
Given a user adds a widget to their dashboard  
When the persistence operation fails due to network error  
Then an error message is displayed to the user  
And the operation is queued for retry  
And the user is notified when the retry succeeds  
And the dashboard state is eventually consistent
```

##### Scenario 5: Retrieve dashboard with invalid widget configuration

```gherkin
Given a dashboard is stored with a widget configuration  
And the widget type schema has been updated  
When the dashboard is retrieved  
Then the widget configuration is validated against the new schema  
And invalid configurations are migrated or reset to defaults  
And the user is notified of any configuration changes  
And the dashboard loads successfully
```

---

**Technical notes:**

- Use optimistic locking or versioning to handle concurrent updates
- Implement event sourcing pattern for auditability (future consideration)
- Consider implementing offline persistence for PWA offline mode
- Ensure database transactions maintain ACID properties
- Implement retry logic with exponential backoff for transient failures
- Use strongly typed entities for persistence mapping

**Open questions:**

- Should there be a maximum history of dashboard changes (undo stack)?
- Should the dashboard state be versioned for rollback capability?
- Should we implement a conflict resolution UI for concurrent updates?

---

## Cross-feature considerations

### Interactions between features

- **Dashboard Creation ↔ Widget Management:** New dashboards start empty; widgets can only be added to existing
dashboards
- **Widget Management ↔ Layout Management:** Adding/removing widgets triggers layout recalculation
- **Widget Reordering ↔ Layout Management:** Reordering updates layout positions; layout constraints govern valid drops
- **Personalization Profiles ↔ All Features:** Each profile has its own dashboard instance, isolating all widget and
layout configurations
- **Dashboard Persistence ↔ All Features:** All features depend on persistence; persistence is the cross-cutting concern

### Shared business rules

1. **Layout Consistency:** All features that modify widget instances must ensure layout positions never overlap
2. **Widget Instance Uniqueness:** Widget instances must have unique identifiers across the entire system
3. **Atomicity:** All state changes must be atomic—either fully succeed or fully fail
4. **Validation:** All widget configurations must validate against widget type schemas before persistence
5. **User Ownership:** All dashboard operations must be scoped to the authenticated user

### Data consistency requirements

- **Strong Consistency:** Dashboard state changes (widget add/remove, reorder, configuration) require strong consistency
- **Eventual Consistency:** Widget data refreshes from downstream contexts can be eventually consistent
- **Transactional Boundaries:** Dashboard aggregate is the transactional boundary; all changes within must be atomic
- **Event Publishing:** Events must be published after successful persistence

---

## Business constraints impact

### BC-001: Budget

Dashboard Management must operate within zero-cost infrastructure constraints:

- **Widget Registry:** Must use in-memory or file-based storage (no external registry service)
- **Event Publishing:** Use local event bus initially; design for future migration to message queue
- **Persistence:** Use free-tier database (PostgreSQL via Railway, Supabase, or local)
- **No paid widget marketplace or CDN** for widget assets

### BC-002: Timeline

Dashboard Management is on the critical path for MVP (3-6 months):

- **Must Have features** (FR-DAS-001, 002, 003, 004, 005, 007, 008) are required for MVP
- **Should Have feature** (FR-DAS-006 Personalization Profiles) may be deferred post-MVP
- Prioritize basic functionality over advanced features
- Profile support (FR-DAS-006) adds complexity; consider MVP with single dashboard only

### BC-003: Resources

Single-developer constraints affect Dashboard Management:

- **Leverage frameworks:** Use existing drag-and-drop libraries (avoid building from scratch)
- **Simplify layout engine:** Start with CSS Grid/Flexbox (defer advanced layout algorithms)
- **Automate testing:** Heavy investment in automated tests for core features
- **Documentation-first:** Complete functional requirements before implementation (TDD/BDD)

### BC-004: Technology stack

Dashboard Management aligns with the chosen stack:

- **Frontend:** Angular components for widget rendering, drag-and-drop (Angular CDK)
- **Backend:** Spring Boot REST APIs for dashboard CRUD operations
- **Database:** PostgreSQL for dashboard/widget/layout persistence
- **Events:** Spring Events initially; design for future Kafka/RabbitMQ migration
- **Validation:** JSON Schema for widget configuration validation

---

## Success metrics alignment

Dashboard Management contributes to the following success metrics from BR-001 through BR-008:

### BR-003: Technical metrics

| Metric                | Target        | Dashboard Management Contribution                            |
|-----------------------|---------------|--------------------------------------------------------------|
| **Page Load Time**    | < 2 seconds   | Efficient dashboard rendering, lazy loading of widget data   |
| **API Response Time** | < 200ms (p95) | Optimized dashboard/widget CRUD operations                   |
| **Test Coverage**     | > 80%         | Comprehensive unit/integration tests for all FR-DAS features |

### BR-001: Portfolio quality metrics

| Metric                         | Target             | Dashboard Management Contribution                    |
|--------------------------------|--------------------|------------------------------------------------------|
| **Architecture Documentation** | All views complete | Dashboard aggregate design, context map, event flows |
| **Code Quality Score**         | No critical issues | DDD patterns, clean code, proper validation          |

### BR-002, BR-005: User experience metrics

| Metric                   | Target            | Dashboard Management Contribution              |
|--------------------------|-------------------|------------------------------------------------|
| **Task Completion Rate** | > 95%             | Intuitive widget add/remove/reorder operations |
| **Mobile Usability**     | Fully Responsive  | Responsive layout adapts to all screen sizes   |
| **Accessibility Score**  | WCAG 2.1 Level AA | Keyboard navigation, screen reader support     |

---

## Traceability matrix

| Feature    | Business Req                   | Domain Events                                      | User Stories               |
|------------|--------------------------------|----------------------------------------------------|----------------------------|
| FR-DAS-001 | BR-001, BR-002, BR-005         | DashboardCreated, UserRegistered                   | US-DAS-001-001/002         |
| FR-DAS-002 | BR-001, BR-002, BR-005         | WidgetAddedToDashboard, WidgetRemovedFromDashboard | US-DAS-002-001/002/003     |
| FR-DAS-003 | BR-001, BR-002, BR-003, BR-005 | WidgetConfigurationChanged                         | US-DAS-003-001/002/003     |
| FR-DAS-004 | BR-001, BR-002, BR-005         | LayoutChanged                                      | US-DAS-004-001/002/003     |
| FR-DAS-005 | BR-001, BR-002, BR-005         | WidgetReordered                                    | US-DAS-005-001/002/003     |
| FR-DAS-006 | BR-001, BR-002, BR-004, BR-005 | ProfileCreated, ProfileSwitched, ProfileDeleted    | US-DAS-006-001/002/003/004 |
| FR-DAS-007 | BR-001, BR-002, BR-005         | DashboardDeleted                                   | US-DAS-007-001/002         |
| FR-DAS-008 | BR-001, BR-002, BR-003, BR-005 | All dashboard events                               | US-DAS-008-001/002         |
